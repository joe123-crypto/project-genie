// pages/api/firebase.ts
import type { NextApiRequest, NextApiResponse } from 'next';
import admin from 'firebase-admin';
import { S3Client, PutObjectCommand, PutObjectCommandInput } from '@aws-sdk/client-s3';

// Initialize Firebase Admin
if (!admin.apps.length) {
  const projectId = process.env.FIREBASE_PROJECT_ID;
  const clientEmail = process.env.FIREBASE_CLIENT_EMAIL;
  const privateKey = process.env.FIREBASE_PRIVATE_KEY?.replace(/\\n/g, '\n');

  if (!projectId || !clientEmail || !privateKey) {
    throw new Error('Missing Firebase Admin credentials in environment variables.');
  }

  admin.initializeApp({
    credential: admin.credential.cert({
      projectId,
      clientEmail,
      privateKey,
    }),
  });

const db = admin.firestore();

// Minimal Filter type used in this route
interface Filter {
  id?: string;
  name?: string;
  description?: string;
  [key: string]: unknown;

  filters?: Filter[];
  filter?: Filter;

// --- Cloudflare R2 (S3-compatible) setup ---
const r2BucketName = process.env.R2_BUCKET_NAME || 'genie-bucket';
const r2Client = new S3Client({
  region: process.env.R2_REGION || 'auto',
  endpoint: process.env.R2_ENDPOINT,
  forcePathStyle: true,
  credentials: process.env.R2_ACCESS_KEY_ID && process.env.R2_SECRET_ACCESS_KEY ? {
    accessKeyId: process.env.R2_ACCESS_KEY_ID,
    secretAccessKey: process.env.R2_SECRET_ACCESS_KEY,
  } : undefined,

/**
 * Parses a data URL (data:mime;base64,...) into { mimeType, buffer }.
 */
function parseDataUrlToBuffer(dataUrl: string): { mimeType: string; buffer: Buffer } {
  const match = /^data:(.+);base64,(.*)$/.exec(dataUrl);
  if (!match) {
    throw new Error('Invalid data URL');
  }
  const mimeType = match[1];
  const base64Data = match[2];
  const buffer = Buffer.from(base64Data, 'base64');
  return { mimeType, buffer };

/**
 * Uploads a data URL image to Cloudflare R2 under a deterministic key and returns a public URL.
 */
async function uploadPreviewToR2(key: string, dataUrl: string): Promise<string> {
  const { mimeType, buffer } = parseDataUrlToBuffer(dataUrl);

  const params: PutObjectCommandInput = {
    Bucket: r2BucketName,
    Key: key,
    Body: buffer,
    ContentType: mimeType,
    ACL: 'public-read', // ACL accepted by R2 for public buckets; can be omitted if bucket policy is public
  };

  await r2Client.send(new PutObjectCommand(params));

  // Prefer a configured public base URL.
  const publicBase = process.env.R2_PUBLIC_BASE_URL;
  if (publicBase) {
    return `${publicBase.replace(/\/$/, '')}/${key}`;
  }
  // Fallback to path-style URL.
  const endpoint = (process.env.R2_ENDPOINT || '').replace(/^https?:\/\//, '').replace(/\/$/, '');
  return `https://${endpoint}/${r2BucketName}/${key}`;

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<FirebaseResponse>
) {
  const { action } = req.query;

  try {
    switch (action) {
      case 'getFilters': {
        const filters: Filter[] = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

      case 'saveFilter': {
        const { filter } = req.body as { filter?: Filter };
        if (!filter) return res.status(400).json({ error: 'Missing filter data' });

        let previewImageUrl: string | unknown = filter.previewImageUrl;

        if (typeof previewImageUrl === 'string' && previewImageUrl.startsWith('data:')) {
          const key = `filters/${docRef.id}/preview`;
          const publicUrl = await uploadPreviewToR2(key, previewImageUrl);
          previewImageUrl = publicUrl;
        }

        await docRef.set({
          ...filter,
          previewImageUrl,
          createdAt: admin.firestore.FieldValue.serverTimestamp(),
          accessCount: 0,

        const newFilterData = (await docRef.get()).data() as Filter;
        const newFilter = { id: docRef.id, ...newFilterData };

      case 'updateFilter': {
        const { filterId, filterData } = req.body as { filterId?: string; filterData?: Partial<Filter> };
        if (!filterId || !filterData) return res.status(400).json({ error: 'Missing filterId or filterData' });

        const updatedData: Partial<Filter> = { ...filterData };
        const incomingPreview = updatedData.previewImageUrl;
        
        if (typeof incomingPreview === 'string' && incomingPreview.startsWith('data:')) {
          const key = `filters/${filterId}/preview`;
          const publicUrl = await uploadPreviewToR2(key, incomingPreview);
          updatedData.previewImageUrl = publicUrl;
        }


        const updatedFilterData = (await docRef.get()).data() as Filter;
        const updatedFilter = { id: docRef.id, ...updatedFilterData };

      case 'deleteFilter': {
        const { filterId } = req.body as { filterId?: string };
        if (!filterId) return res.status(400).json({ error: 'Missing filterId' });

        await db.collection('filters').doc(filterId).delete();

      case 'incrementAccessCount': {
        const { filterId } = req.body as { filterId?: string };
        if (!filterId) return res.status(400).json({ error: 'Missing filterId' });

          accessCount: admin.firestore.FieldValue.increment(1),

      default:
        return res.status(400).json({ error: 'Unknown action' });
    }
  } catch (err: unknown) {
    console.error('Firebase API error:', err);
    if (err instanceof Error) {
      return res.status(500).json({ error: err.message });
    }
    return res.status(500).json({ error: 'Internal server error' });
  }
  id?: string;
  name?: string;
  description?: string;
  [key: string]: unknown;

  filters?: Filter[];
  filter?: Filter;

      case 'getOutfits': {

      case 'incrementOutfitAccessCount': {

          accessCount: admin.firestore.FieldValue.increment(1),
